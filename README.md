<img src="https://cdn.dribbble.com/users/1885550/screenshots/3795640/akita-inu.jpg" align="right" width="300px"></img>
<h1>Akita.AI - Рекомендательная система</h1>

<h3><b>Систему разработали студенты группы 0391:</b></h3>
<ul> 
  <li>Андрющенко Ксения</li>
  <li>Асташёнок Михаил</li>
</ul>
<br>

<h3>Введение</h3>
<p>Система разработана в рамках Альтернативного Экзамена по дискретной математике 2021 по теме "Рекомендательные системы". Данный проект включает в себя два реализованых алгоритма работы систем основанных на коллаборативной фильтрации и на контенте. Ознакомиться с теоретическим материалом по теме "Рекомендательные системы" можно с документами "РС: Теория" и "РС: Презентация", находящимися в директории с материалами нашей команды.</p>
<br>

<h3>Краткая характеристика содержимого репозитория:</h3>
<ul> 
  <li><b>collaborative.py</b> - код реализованной РС, основанной на коллаборативной фильтрации.</li>
  <li><b>content-based.py</b> - код реализованной РС, основанной на контенте.</li>
  <li><b>database.json</b> - кастомная база данных для демонстрации работы системы.</li>
  <li><b>json_implementation.py</b> - небольшой самодельный модуль для взаимодействия с JSON базой данных.</li>
  <li><b>config.py</b> - конфигурационный файл. Несмотря на то, что содержит лишь одну переменную, при редактировании и увеличении сложности проекта, такие конфигурационные файлы становятся крайне полезны.</li>
</ul>
<p>Файлы <b>.gitignore</b> и <b>README.md</b> служат для облегчения разработки и документирования программы. Они никак не относятся к работе программы</p>
<br>

<h3>Collaborative.py - коллаборативная фильтрация </h3>
<p>Вспомним, каким образом происходит коллаборативная фильтрация в рекомендательной системе, основанной на одноименном методе. При этом рекомендательном методе мы не интересуемся самим продуктом, его содержимым настолько, насколько интересуемся оценками этого продукта другими пользователями, чьи интересы схожи с нашими. Данные о пользователе мы представляем в виде вектора оценок, которые он поставил тому или иному предмету. Количество координат вектора равно количеству имеющихся в "ассортименте" наименований предметов. Для рассчета близости интересов пользователей воспользуемся формулой рассчета <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C#%D0%9A%D0%BE%D1%81%D0%B8%D0%BD%D1%83%D1%81%D0%BD%D0%BE%D0%B5_%D1%81%D1%85%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE">косинусного сходства</a>. Напомню, что чем ближе косинусное сходство к единице, тем более похожи друг на друга вектора.</p>
<br>

<h4> Перейдем к коду: </h4>
<p>Для начала импортируем необходимые модули: <b>numpy</b> для работы с векторами и <b>json_implementation</b> для загрузки данных</p>
```python
import numpy as np
import json_implementation as ji
```
<p>Загрузим массив векторов уже заразервированных пользователей:</p>
```python
ratings = ji.json_get_data()["collaborative_filtering_ratings"]
```
<p>Определим вектор пользователя, для которого будем искать косинусного сходства с другими пользователями:</p>
```python
handling_user_ratings = [1, 3, 0, 0, 0]
```

<p>Теперь определим функцию косинусного сходства <b>cosine(ratings_a, ratings_b)</b></p>
```python
def cosine(ratings_a, ratings_b):
    length_a = np.linalg.norm(ratings_a)
    length_b = np.linalg.norm(ratings_b)

    distance = np.dot(ratings_a, ratings_b) / np.dot(length_a, length_b)
    return distance
```
<p> На вход данной функции принимается два вектора пользовательских оценок, между которыми мы и будем искать косинусное сходство. С помощью метода <b>np.linalg.norm()</b> запишем в переменные <b>length_*</b> длины векторов. Косинусное расстояние <b>distance</b> вычислим как частное скалярного произведения векторов и произведения длин тех же векторов.</p>

<p>Теперь проведем рассчет и сравним вектор нашего заданного пользователя со всеми заразервированными пользователями:</p>
```python
cosine_values = []
for user_ratings in ratings:
    current_distance = cosine(handling_user_ratings, user_ratings)
    cosine_values.append({current_distance: user_ratings})
   
cosine_values.sort(key=lambda item: sorted(list(item.keys())), reverse=True)
print(cosine_values)
```
<p> Создали пустой массив <b>cosine_values</b>, который будет хранить в себе объекты : "вектор" : "косинусное сходство с заданным пользователем". Цикл перебирает каждый вектор в массиве векторов, сохраняет в переменную <b>current_distance</b> результат подсчета косинусного сходства заданного и итерируемого пользователя и записывает в массив новый объект. Методом массивов <b>.sort()</b> сортируем в обратном порядке массив косинусных расстояний - ведь чем больше косинусное расстояне , тем более похожий на заданного пользователя итерируемый пользователь.</p>
<p>Запускаем .py документ и наблюдаем: </p>
```
[{0.9534625892455924: [1, 3, 0, 1, 0]}, {0.8280786712108251: [0, 4, 1, 0, 2]}, {0.7911548052852398: [1, 4, 3, 0, 1]}, {0.760638829255665: [3, 2, 0, 1, 0]}, {0.5976143046671968: [1, 3, 0, 3, 3]}, {0.50709255283711: [3, 1, 0, 0, 2]}, {0.42426406871192845: [0, 1, 0, 2, 0]}, {0.35233213170882205: [0, 2, 3, 0, 4]}, {0.3450327796711771: [2, 1, 0, 4, 0]}, {0.29814239699997197: [4, 0, 1, 1, 0]}, {0.28603877677367767: [0, 1, 0, 3, 1]}, {0.28284271247461895: [2, 0, 0, 0, 1]}, {0.2300894966542111: [0, 1, 4, 0, 0]}, {0.07254762501100116: [1, 0, 3, 3, 0]}, {0.0: [0, 0, 1, 3, 4]}, {0.0: [0, 0, 3, 1, 2]}]
```
<p>Как можем заметить, первый вектор <b>[1, 3, 0, 1, 0]</b> система принимает за самый похожий на наш заданный <b>[1, 3, 0, 0, 0]</b>. И ведь это именно так!</p>
